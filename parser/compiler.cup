// CUP specification for a simple expression evaluator (w/ actions)

//todo: % et ! (not)

import java_cup.runtime.*;
import java.lang.Number;
import java.util.*;


action code {:
	public void show_error(int ligne, int colonne) {
         System.out.println("--- Error ---" );
         System.out.println("Ligne " +ligne+ " -- Colonne " +colonne);
    }

    HashMap<String,EnumType> varTab = new HashMap<String,EnumType>();
    Stack<HashMap> stack = new Stack<HashMap>();
:};

parser code {:
	public void syntax_error(Symbol cur_token){
		System.out.println("--- Error ---" );
        System.out.println("Ligne " +(cur_token.left + 1)+ " -- Colonne " + (cur_token.right + 1));
        report_error("Syntax error", null);
	}

	public void unrecovered_syntax_error(Symbol cur_token)
	{
		System.out.println("--- Error ---" );
        System.out.println("Ligne " +(cur_token.left + 1)+ " -- Colonne " + (cur_token.right + 1));
		System.out.println("unrecovered_syntax_error");
	}
:};

init with {:

:};


terminal LPAR, RPAR, LPARTAB, RPARTAB, PLUS, MINUS, MULT, DIV, MINUS_U, SEMIC, AND, OR, EQUAL, DIFF, INF, INFE, SUP, SUPE, AFFECT, TRUE, FALSE, TAB, INDTAB, MOD, NOT, COLON, LSQUAREBRACKET, RSQUAREBRACKET;
terminal PROP, CHAINE;
terminal EnumType TYPE;
terminal String VAR;
terminal Integer NUMBERINT;
terminal Float NUMBERFLOAT;
terminal String CHARACTER;
terminal String STRING;
terminal INT, UINT, FLOAT, BOOL, CHAR;
terminal ASSIGN;
terminal IF, WHILE;
terminal ELSE;
terminal LBRACKET;
terminal RBRACKET;



non terminal flow;
non terminal Instruction instruction;
non terminal Instruction assign;
non terminal Instruction ifInstr;
non terminal Instruction whileInstr;
non terminal Instruction block;
non terminal declaration;
non terminal Vector<Instruction> subFlow;
non terminal Vector<Expression> array;
non terminal Expression expression;

precedence left OR;
precedence left AND;
precedence left EQUAL, DIFF;
precedence left INF, SUP, INFE, SUPE;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left MINUS_U;

precedence right ELSE;

start with flow;

flow ::=
	flow instruction:instr {: 	if(instr != null){
									Label nextLabel = new Label();
									instr.generateCode(nextLabel);//, stack);
									System.out.println(nextLabel.print() + ":"); 
								} :}
	|						{: stack.push(varTab); :}
	;

instruction ::=
	assign:a {: RESULT = a; :}
	| ifInstr:instr {: RESULT = instr; :}
	| whileInstr:instr {: RESULT = instr; :}
	| block:b {: RESULT = b; :}
	| declaration:d {: RESULT = null; :}
	;

declaration ::=
	TYPE:type VAR:var SEMIC {: RESULT = null; varTab.put(var, type); :}
	|TYPE:type VAR:var array SEMIC {: RESULT = null; varTab.put(var, type); :}
	;
assign ::=
	TYPE:type VAR:var ASSIGN expression:expr SEMIC {: RESULT = new Assign(var, expr); varTab.put(var, type); :}
	|VAR:var ASSIGN expression:expr SEMIC {: RESULT = new Assign(var, expr); :}
	|TYPE:type VAR:var LSQUAREBRACKET expression:i RSQUAREBRACKET ASSIGN expression:expr SEMIC {: RESULT = new Assign(var, i, expr); varTab.put(var, type); :}
	|VAR:var LSQUAREBRACKET expression:i RSQUAREBRACKET ASSIGN expression:expr SEMIC {: RESULT = new Assign(var, i, expr); :}
	;

expression ::=
	expression:expr1 EQUAL expression:expr2 {: RESULT = new Comparison(expr1, EnumOps.EQ, expr2); :}
	|expression:expr1 DIFF expression:expr2 {: RESULT = new Comparison(expr1, EnumOps.DIFF, expr2); :}
	|expression:expr1 INF expression:expr2 {: RESULT = new Comparison(expr1, EnumOps.LT, expr2); :}
	|expression:expr1 INFE expression:expr2 {: RESULT = new Comparison(expr1, EnumOps.LE, expr2); :}
	|expression:expr1 SUP expression:expr2 {: RESULT = new Comparison(expr1, EnumOps.GT, expr2); :}
	|expression:expr1 SUPE expression:expr2 {: RESULT = new Comparison(expr1, EnumOps.GE, expr2); :}
	|expression:expr1 PLUS expression:expr2 {: RESULT = new BinaryArithmeticOperation(expr1, EnumOps.PLUS, expr2); :}
	|expression:expr1 MINUS expression:expr2 {: RESULT = new BinaryArithmeticOperation(expr1, EnumOps.MINUS, expr2); :}
	|expression:expr1 MOD expression:expr2 {: RESULT = new BinaryArithmeticOperation(expr1, EnumOps.MOD, expr2); :}
	|expression:expr1 MULT expression:expr2 {: RESULT = new BinaryArithmeticOperation(expr1, EnumOps.MULT, expr2); :}
	|expression:expr1 DIV expression:expr2 {: RESULT = new BinaryArithmeticOperation(expr1, EnumOps.DIV, expr2); :}
	|expression:expr1 AND expression:expr2 {: RESULT = new And(expr1, expr2); :}
	|expression:expr1 OR expression:expr2 {: RESULT = new Or(expr1, expr2); :}
	|NOT expression:expr1 {: RESULT = new UnaryArithmeticExpression(EnumOps.NOT, expr1); :}
	|MINUS expression:expr1 {: RESULT = new UnaryArithmeticExpression(EnumOps.MINUS, expr1); :}
	|PLUS expression:expr1 {: RESULT = expr1; :}
	|LPAR expression:expr1 RPAR {: RESULT = expr1; :}  
 	|VAR:v {: RESULT = new VariableExpression(v); :}
 	|NUMBERINT:n {: RESULT = new ConstantExpression(n); :}
 	|NUMBERFLOAT:n {: RESULT = new ConstantExpression(n); :}
	|BOOL:b {: RESULT = new ConstantExpression(b); :}
	|VAR:v array:a {: RESULT = new Array(v, a);:}
	|CHARACTER:c {: RESULT = new ConstantExpression(c); :}
	|STRING:s {: RESULT = new ConstantExpression(s); :}
	;


block ::= 
	LBRACKET subFlow:f RBRACKET {: RESULT = new BlockInstruction(f); :}
	;

subFlow ::=
	subFlow:vectorInstr instruction:instr {: vectorInstr.add(instr); RESULT = vectorInstr; :}
	| {: Vector<Instruction> vectorInstr = new Vector<Instruction>(); RESULT = vectorInstr; :}
	;

array ::=
	array:a LSQUAREBRACKET expression:e RSQUAREBRACKET {: a.add(e); RESULT = a; :}
	| LSQUAREBRACKET expression:e RSQUAREBRACKET {: Vector<Expression> v = new Vector<Expression>(); v.add(e); RESULT = v;:}
	;
whileInstr ::=
	WHILE LPAR expression:cond RPAR instruction:instr {: RESULT = new While(cond,instr); :}
	;


ifInstr ::=
	IF LPAR expression:cond RPAR instruction:instr {: RESULT = new If(cond, instr); :}
	|IF LPAR expression:cond RPAR instruction:ifInstr ELSE instruction:elseInstr {: RESULT = new Else(cond, ifInstr, elseInstr); :}
	;



/*
//start with statements; //normal mode
//start with expr_num_test; //expr_num test
start with expr_bool_test; //expr_bool test


////////////////////////////TEST D'EXPR_NUM
expr_num_test ::=
        expr_num:e {: e.generateCode(); :}
	;
//////////////////////////////////////


////////////////////////////TEST D'EXPR_NUM
expr_bool_test ::=
        expr_bool:e {: e.generateCode(); :}
	;
//////////////////////////////////////

statements ::=
	statements statement
	|statement;

statement ::=
	expr_num:e SEMIC {: :}
	|expr_bool:e SEMIC {: :}
	|expr_complex:e SEMIC {: :}
	|expr_num_decl SEMIC {: :}
	|expr_bool_decl SEMIC {: :}			 
	;

expr_num_decl ::=
	VAR:n INT {: :}
	|VAR:n UINT {: :}
	|VAR:n FLOAT {:  :}
	|VAR:n1 INT AFFECT expr_num:n2 {: :}
	|VAR:n1 UINT AFFECT expr_num:n2 {: :}
	|VAR:n1 FLOAT AFFECT expr_num:n2 {: :}	
	|VAR:n1 AFFECT expr_num:n2 {: :}
	;

expr_bool_decl ::=
	VAR:p BOOL {: :}
	|VAR:p1 BOOL AFFECT expr_bool:p2 {: :}
	|VAR:p1 AFFECT expr_bool:p2 {: :}
	;




expr_num ::=
	expr_num:n1 PLUS expr_num:n2 {: RESULT = new BinaryArithmeticOperation(n1, EnumOps.PLUS, n2); :}
	|expr_num:n1 MINUS expr_num:n2 {: :}
	|expr_num:n1 TIMES expr_num:n2 {: :}
	|expr_num:n1 DIVIDE expr_num:n2 {: :}
    |LPAR:lpar expr_num:e RPAR:rpar {: :}
	|NUMBER:n {: RESULT = new Nombre(n); :}
	|VAR:n1 {: RESULT = new Variable(n1); :}
	|var_tableau:n {: :}
	;    

expr_bool ::=
	expr_bool:p1 AND expr_bool:p2 {: :}
	|expr_bool:p1 OR expr_bool:p2 {:  :}
	//|expr_num:n1 EQUAL expr_num:n2 {:  :}
	//|expr_num:n1 DIFF expr_num:n2 {:  :}
	|expr_bool:p1 EQUAL expr_bool:p2 {:  :}
	|expr_bool:p1 DIFF expr_bool:p2 {:  :}
	//|expr_num:n1 SUP expr_num:n2 {:  :}
	//|expr_num:n1 INF expr_num:n2 {:  :}
	//|expr_num:n1 SUPE expr_num:n2 {:  :}
	//|expr_num:n1 INFE expr_num:n2 {:  :}
	|BOOL:p {: System.out.println(p); :} 
	//|expr_num {: :}
	//|VAR:p {: :}
	//|var_tableau:p {: :}
	;


dim_tableau ::=                            
	dim_tableau:t1 indtab:t2 {: :}
	|indtab:t {: :}
	;

indtab ::=                                 // INDTAB = "[i]" dans "tab[i]" 
	LPARTAB NUMBER:i RPARTAB {: :}
	|LPARTAB VAR:i RPARTAB {: :}
	;

var_tableau ::=
	VAR dim_tableau:t {: :}
	;

expr_complex_decl ::= 
	VAR:c1 INT dim_tableau {:  :}
	|VAR:c1 UINT dim_tableau {:  :}
	|VAR:c1 FLOAT dim_tableau {:  :}
	|VAR:c1 BOOL dim_tableau {:  :}
	|VAR:c1 TAB dim_tableau {:  :}
	|VAR:c1 INDTAB:c2 AFFECT expr_num:c3 {: :}
	|VAR:c1 INDTAB:c2 AFFECT expr_bool:c3 {: :}
	|VAR:c1 INDTAB:c2 AFFECT VAR:c3 {: :}   // On suppose que l'on peut ainsi d√©clarer des tableaux de tableaux
	|VAR:c1 AFFECT CHAINE:c2 {: :}
	;
	
	*/


